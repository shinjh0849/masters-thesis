In this chapter, we will discuss about how this approach is important in the software engineering practice, especially in automated quality assurance technique and the future work.

\section{Importance of this Approach}
It is necessary to find the right threshold value to separate clean instances from buggy instances in the future.
We used different threshold values for different test projects with which we could only linearly separate the relationship among the classes.
However, more studies should be conducted to distinguish the relationship using a more complex and non-linear approach.
It was difficult to determine a global threshold that was suitable for all the projects.
However, finding it is crucial for the predictor to work on future projects because historical data are not available to help find the best threshold value.

Additionally, the suggested BFCs can be used as a code ingredient or mutation operator in automatic program repair (APR).
In APR, reducing the search space is critical to find the right patch within a feasible time. Ingredients or a list of operators retrieved from the suggested BFC can help reduce the search space to find the correct patch.
So these patch suggestions not only has high potential for actionable defect prediction but also for more efficient APR technique as well.

% Our defect-prediction approach is novel in that we built a large AED model of 199 projects to encode various change data and use the distance values achieved from the kNN model to make the prediction.
% Our {\simfinmo} is fully universal which can be fully utilized in a CPDP setting without the need of historical metrics.
% With this approach, we can say that the cold-start problem is fully alleviated.
% Another major problem of defect prediction is the lack of actionable messages.
% Traditional defect-prediction models predict the risk of a module in a file or at a method level.
% For larger projects, developers need a significant amount of time to find the bug inside the risky module and fix it.
% JIT-DP was actively studied to resolve the issue because code changes were typically significantly smaller than an entire file or method.
% By reducing the granularity, developers can easily identify the location of the defect as the code to be inspected is shorter.
% However, it does not resolve the fundamental problem.
% JIT-DP does not inform the developers how the defect can be corrected.
% Using {\simfinmo}, we can identify a risky change and also show the original BFC that is associated with the BIC with the nearest distance value.
% The suggested BFC can act as an actionable message and provide insights to assist developers in fixing the risky change.
% Fig. \ref{fig:ps_1} shows an example of a BFC that we collected from project tez, one of the testing projects.
% Fig. \ref{fig:ps_2} shows an example of a suggested BFC generated by running SimFinMo on the BIC that is shown in Fig. \ref{fig:ps_1}.
% Fig. \ref{fig:ps_2} shows that one parameter for calling a super constructor is added for a change.
% By looking at Fig. \ref{fig:ps_1}, we can see that first and the third change is very similar to the suggested patch in that they are both adding a parameter in a method invocation.
% Fig. \ref{fig:ps_2} added an AppContext instance as a parameter as its method creates a common container launcher context while Fig. 3 added an EventType info parameter as it is related to a handler method.
% Based on the change context, developers can get an actionable message such as adding a missing parameter.
% As the example illustrates, we hope that these suggested patches will help developers to act upon for quality assurance activity.
% Our method of defect prediction is a novel technique which does not use machine learning algorithm in the prediction phase.
% In existing studies such as traditional, cross-project, heterogeneous, and just-in-time defect prediction, major issues are caused by the short comings of machine learning techniques.
% Cold-start problem is caused because training data is necessary for the model to be build from the target project.
% This issue is alleviated through the study of CPDP, however, CPDP does not perfectly solve the cold-start problem because many of the approaches use historical metrics as a feature. 
% Because {\simfinmo} exploits existing software projects without the need of historical metrics, it fully resolves the cold-start problem.

% Another major problem of defect prediction is the lack of actionable messages to act upon. 
% Traditional defect prediction model predicted the risk of module in a file or method level.
% For larger projects, developers needed so much time to find the bug inside the risky module and to find the fix for it.
% To resolve this issue, JIT-DP  was actively studied because a code change were usually a lot smaller than a whole file or method.
% By making the granularity smaller, developers can easily identify the location of the defect relatively because there are shorter amount of code to inspect.
% However, this does not resolve the fundamental problem.
% JIT-DP does not tell the developers how to correct the defect.
% By using {\simfinmo}, we can identify which change is risky and we can also show the original BFC which is associated to the BIC that has the nearest distance value.
% The suggested BFC might not be the exact fix for the defect, however, it can provide some ideas to assist on fixing the risky change to the developer.

\section{Future Work}
It is necessary to find the right threshold value to separate clean instances and buggy instances in the future.
Currently we used different values for different test projects which can only cut the relationship of the classes linearly.
However, more studies can be proposed to distinguish this relationship in a more complex, non-linear way.
Currently, it is difficult to find a global threshold that will work best for all the projects.
This is crucial for the predictor to work on newly started project because there are no historical data to find the best threshold.

Also, it is promising to use the suggested BFCs as an ingredient or operation list that can be used in the automatic program repair field.
In the field of automatic program repair, reducing the search space is critical to find the right patch within a feasible time.
Ingredients retrieved from suggested BFC could be very helpful to reduce the search space of finding the correct patch.
Fig. \ref{fig:ps_1} is an instance of BFC that we collected from project tez, one of the test project. 
A BIC is retrieved from blame tracing the deleted BFC lines.
When a BIC is retrieved, it searches for the most similar change in a repository.
From the searched similar change, we can get the associated BFC, which is show at Fig. \ref{fig:ps_2}.
BFC from Fig. \ref{fig:ps_1} shows that a parameter of a method invocation was deleted.
BFC from Fig. \ref{fig:ps_2} shows that a different method was invoked with one less parameter.
Even though the second change was calling a different method, we can infer that the two methods have a similar function by looking at the method name (addHtmlComponent and addComponent) and the parameters they are using.
Despite the different context (different project, return type of method) we can get a hint of which operation to use in automatic program repair, which is update method, or update method parameter.
With these hints, we can help automatic program repair approaches to reduce the search space of operation they use to enlarge other search spaces.


\begin{figure}[!tbp]
\renewcommand{\arraystretch}{1}
    \centering
    \includegraphics[width=\linewidth]{figures/ps1.png}\hfill
    \caption{An example of a ground truth BFC from project tez.}
    \label{fig:ps_1}
\end{figure}

\begin{figure}[!tbp]
\renewcommand{\arraystretch}{1}
    \centering
    \includegraphics[width=\linewidth]{figures/ps2.png}\hfill
    \caption{An example of suggested BFC from the project hbase.}
    \label{fig:ps_2}
\end{figure}